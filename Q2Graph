
import random
from Question2_UI import terminal_ui
class Person:
    def __init__(self,username="default", bio="Default",privacy="Open",gender="None"):
        self.username=username
        self.bio=bio
        self.privacy=privacy
        self.gender=gender
    def __str__(self):
        if self.privacy.lower() == "private":
            return f"Name: {self.username}\nGender: {self.gender}\nBio: [Hidden]"
        else:
            return f"Name: {self.username}\nBio: {self.bio}"

class Graph:
    #Initialize the graph with initial node of None
    def __init__(self, edges=None,bio="default", privacy="Open"):
        self.graph_dict = {}
        self.bio=bio
        self.__privacy=privacy
        if edges is not None:
            #if a tuple/ connection is parsed into Graph contructor call add_connection
            self.add_connection(edges)

    #Adds one or more directed edges to the graph
    def add_connection(self, edges):
        for start, end in edges:
            # Ensure both nodes exist in the dictionary
            if start not in self.graph_dict:
                self.graph_dict[start] = []
            if end not in self.graph_dict:
                self.graph_dict[end] = []

            # Add the edge only if it's not a duplicate
            if end not in self.graph_dict[start]:
                self.graph_dict[start].append(end)

    def unfollow(self, edges):
        for start, end in edges:
            if self.is_related(start, end):
                if start in self.graph_dict and end in self.graph_dict[start]:
                    self.graph_dict[start].remove(end)

    def get_followers(self,node):
        followers = []
        for start_node, neighbors in self.graph_dict.items():  # Fixed iteration
            if node in neighbors:  # Check if target is in neighbor list
                followers.append(start_node)
        return followers

    def get_following(self,node):
        return self.graph_dict[node]

    def is_related(self, start, end, visited=None):
        # Initialize visited set if not provided (for first call)
        if visited is None:
            visited = set()

        # Check if start exists in graph
        if start not in self.graph_dict:
            return False

        # Check direct connections
        if end in self.graph_dict[start]:
            return True

        # Mark current node as visited
        visited.add(start)

        # Recursively check all unvisited neighbors
        for neighbor in self.graph_dict[start]:
            if neighbor not in visited:
                if self.is_related(neighbor, end, visited):
                    return True

        return False
    # get the distance between target user and all other users
    def get_connection_distances(self, start):
        from collections import deque

        distances = {}
        visited = set()
        queue = deque([(start, 0)])  # (user, distance)

        while queue:
            current, dist = queue.popleft()
            if current not in visited:
                visited.add(current)
                distances[current] = dist
                for neighbor in self.graph_dict.get(current, []):
                    if neighbor not in visited:
                        queue.append((neighbor, dist + 1))
        return distances

    # Recommend friends based on the distance betwenen users
    def recommend_friends(self, user):
        distances = self.get_connection_distances(user)
        direct_friends = set(self.graph_dict.get(user, []))

        # Recommend users who are within 2-3 degrees and not already friends
        recommendations = {
            u: d for u, d in distances.items()
            if u != user and u not in direct_friends and 1 < d <= 3
        }
        # Sort by distance
        return sorted(recommendations.items(), key=lambda x: x[1])

    # Return all users
    def get_users(self,graph_dict):
        return list(self.graph_dict.keys())

    def get_bio(self,node,privacy):
        if privacy=="Private":
            return "Private Profile"

        else:
            return self.bio

    def generate_Profile(self):
        # Collect all unique usernames from the graph (keys and values)
        for user, follows in social.graph_dict.items():
            user_list.add(user)
            for follow in follows:
                user_list.add(follow)

        for username in user_list:
            bio = random.choice(random_bio)
            privacy = random.choice(["private", "open"])  # Needs to be a list, not two strings
            gender = random.choice(["Male", "Female"])
            person_profiles[username] = Person(username, bio, privacy, gender)

if __name__=="__main__":
    random_bio=["Ball","Cook","Study","Strong","Sad"]
    user_list=set()
    person_profiles = {}
    connections = [
        ("Alice", "Bob"),
        ("Alice", "Charlie"),
        ("Bob", "Diana"),
        ("Diana", "Alice"),
        ("Eve", "Alice"),
        ("Eve", "Charlie"),
        ("Charlie", "Eve")
    ]



    # social.add_connection([("Alice", "BRUH")])



    social = Graph()
    social.add_connection(connections)
    social.generate_Profile()

    # print(social.bio)
    # print(social.graph_dict)
    # print(social.get_followers("BRUH"))
    # print(social.get_following("BRUH"))
    # print(social.is_related("Alice", "Eve",visited=set()))
    # print(person_profiles["Alice"])
    # social.unfollow([("Alice","BRUH")])
    # print(social.graph_dict)
    # for user in social.graph_dict.keys():
    #     set_profile(user, social.graph_dict[user], len(social.get_followers(user)),"I Like Tutrles")
    #
    terminal_ui(social, person_profiles)
